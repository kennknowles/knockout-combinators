(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/prelude-ls/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./prelude.js\"}\n//@ sourceURL=/node_modules/prelude-ls/package.json"
));

require.define("/node_modules/prelude-ls/prelude.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// prelude.ls 0.6.0\n// Copyright (c) 2012 George Zahariev\n// Released under the MIT License\n// raw.github.com/gkz/prelude-ls/master/LICNSE\nvar objToFunc, each, map, filter, reject, partition, find, first, head, tail, last, initial, empty, values, keys, length, cons, append, join, reverse, foldl, fold, foldl1, fold1, foldr, foldr1, unfoldr, andList, orList, any, all, unique, sort, sortBy, compare, sum, product, average, mean, concat, concatMap, listToObj, maximum, minimum, scanl, scan, scanl1, scan1, scanr, scanr1, replicate, take, drop, splitAt, takeWhile, dropWhile, span, breakIt, zip, zipWith, zipAll, zipAllWith, compose, curry, id, flip, fix, lines, unlines, words, unwords, max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm, toString$ = {}.toString, slice$ = [].slice;\nexports.objToFunc = objToFunc = function(obj){\n  return function(key){\n    return obj[key];\n  };\n};\nexports.each = each = curry$(function(f, xs){\n  var i$, x, len$;\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (i$ in xs) {\n      x = xs[i$];\n      f(x);\n    }\n  } else {\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      f(x);\n    }\n  }\n  return xs;\n});\nexports.map = map = curry$(function(f, xs){\n  var type, key, x, res$, i$, len$, result, results$ = {};\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  type = toString$.call(xs).slice(8, -1);\n  if (type === 'Object') {\n    for (key in xs) {\n      x = xs[key];\n      results$[key] = f(x);\n    }\n    return results$;\n  } else {\n    res$ = [];\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      res$.push(f(x));\n    }\n    result = res$;\n    if (type === 'String') {\n      return result.join('');\n    } else {\n      return result;\n    }\n  }\n});\nexports.filter = filter = curry$(function(f, xs){\n  var type, key, x, res$, i$, len$, result, results$ = {};\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  type = toString$.call(xs).slice(8, -1);\n  if (type === 'Object') {\n    for (key in xs) {\n      x = xs[key];\nif (f(x)) {\n        results$[key] = x;\n      }\n    }\n    return results$;\n  } else {\n    res$ = [];\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      if (f(x)) {\n        res$.push(x);\n      }\n    }\n    result = res$;\n    if (type === 'String') {\n      return result.join('');\n    } else {\n      return result;\n    }\n  }\n});\nexports.reject = reject = curry$(function(f, xs){\n  var type, key, x, res$, i$, len$, result, results$ = {};\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  type = toString$.call(xs).slice(8, -1);\n  if (type === 'Object') {\n    for (key in xs) {\n      x = xs[key];\nif (!f(x)) {\n        results$[key] = x;\n      }\n    }\n    return results$;\n  } else {\n    res$ = [];\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      if (!f(x)) {\n        res$.push(x);\n      }\n    }\n    result = res$;\n    if (type === 'String') {\n      return result.join('');\n    } else {\n      return result;\n    }\n  }\n});\nexports.partition = partition = curry$(function(f, xs){\n  var type, passed, failed, key, x, i$, len$;\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  type = toString$.call(xs).slice(8, -1);\n  if (type === 'Object') {\n    passed = {};\n    failed = {};\n    for (key in xs) {\n      x = xs[key];\n      (f(x) ? passed : failed)[key] = x;\n    }\n  } else {\n    passed = [];\n    failed = [];\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      (f(x) ? passed : failed).push(x);\n    }\n    if (type === 'String') {\n      passed = passed.join('');\n      failed = failed.join('');\n    }\n  }\n  return [passed, failed];\n});\nexports.find = find = curry$(function(f, xs){\n  var i$, x, len$;\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (i$ in xs) {\n      x = xs[i$];\n      if (f(x)) {\n        return x;\n      }\n    }\n  } else {\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      if (f(x)) {\n        return x;\n      }\n    }\n  }\n});\nexports.head = head = exports.first = first = function(xs){\n  if (!xs.length) {\n    return;\n  }\n  return xs[0];\n};\nexports.tail = tail = function(xs){\n  if (!xs.length) {\n    return;\n  }\n  return xs.slice(1);\n};\nexports.last = last = function(xs){\n  if (!xs.length) {\n    return;\n  }\n  return xs[xs.length - 1];\n};\nexports.initial = initial = function(xs){\n  if (!xs.length) {\n    return;\n  }\n  return xs.slice(0, xs.length - 1);\n};\nexports.empty = empty = function(xs){\n  var x;\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (x in xs) {\n      return false;\n    }\n    return true;\n  }\n  return !xs.length;\n};\nexports.values = values = function(obj){\n  var i$, x, results$ = [];\n  for (i$ in obj) {\n    x = obj[i$];\n    results$.push(x);\n  }\n  return results$;\n};\nexports.keys = keys = function(obj){\n  var x, results$ = [];\n  for (x in obj) {\n    results$.push(x);\n  }\n  return results$;\n};\nexports.length = length = function(xs){\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    xs = values(xs);\n  }\n  return xs.length;\n};\nexports.cons = cons = curry$(function(x, xs){\n  if (toString$.call(xs).slice(8, -1) === 'String') {\n    return x + xs;\n  } else {\n    return [x].concat(xs);\n  }\n});\nexports.append = append = curry$(function(xs, ys){\n  if (toString$.call(ys).slice(8, -1) === 'String') {\n    return xs + ys;\n  } else {\n    return xs.concat(ys);\n  }\n});\nexports.join = join = curry$(function(sep, xs){\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    xs = values(xs);\n  }\n  return xs.join(sep);\n});\nexports.reverse = reverse = function(xs){\n  if (toString$.call(xs).slice(8, -1) === 'String') {\n    return xs.split('').reverse().join('');\n  } else {\n    return xs.slice().reverse();\n  }\n};\nexports.fold = fold = exports.foldl = foldl = curry$(function(f, memo, xs){\n  var i$, x, len$;\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (i$ in xs) {\n      x = xs[i$];\n      memo = f(memo, x);\n    }\n  } else {\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      memo = f(memo, x);\n    }\n  }\n  return memo;\n});\nexports.fold1 = fold1 = exports.foldl1 = foldl1 = curry$(function(f, xs){\n  return fold(f, xs[0], xs.slice(1));\n});\nexports.foldr = foldr = curry$(function(f, memo, xs){\n  return fold(f, memo, xs.reverse());\n});\nexports.foldr1 = foldr1 = curry$(function(f, xs){\n  xs.reverse();\n  return fold(f, xs[0], xs.slice(1));\n});\nexports.unfoldr = exports.unfold = unfoldr = curry$(function(f, b){\n  var that;\n  if ((that = f(b)) != null) {\n    return [that[0]].concat(unfoldr(f, that[1]));\n  } else {\n    return [];\n  }\n});\nexports.andList = andList = function(xs){\n  return fold(function(memo, x){\n    return memo && x;\n  }, true, xs);\n};\nexports.orList = orList = function(xs){\n  return fold(function(memo, x){\n    return memo || x;\n  }, false, xs);\n};\nexports.any = any = curry$(function(f, xs){\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  return fold(function(memo, x){\n    return memo || f(x);\n  }, false, xs);\n});\nexports.all = all = curry$(function(f, xs){\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  return fold(function(memo, x){\n    return memo && f(x);\n  }, true, xs);\n});\nexports.unique = unique = function(xs){\n  var result, i$, x, len$;\n  result = [];\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (i$ in xs) {\n      x = xs[i$];\n      if (!in$(x, result)) {\n        result.push(x);\n      }\n    }\n  } else {\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      if (!in$(x, result)) {\n        result.push(x);\n      }\n    }\n  }\n  if (toString$.call(xs).slice(8, -1) === 'String') {\n    return result.join('');\n  } else {\n    return result;\n  }\n};\nexports.sort = sort = function(xs){\n  return xs.concat().sort(function(x, y){\n    switch (false) {\n    case !(x > y):\n      return 1;\n    case !(x < y):\n      return -1;\n    default:\n      return 0;\n    }\n  });\n};\nexports.sortBy = sortBy = curry$(function(f, xs){\n  if (!xs.length) {\n    return [];\n  }\n  return xs.concat().sort(f);\n});\nexports.compare = compare = curry$(function(f, x, y){\n  switch (false) {\n  case !(f(x) > f(y)):\n    return 1;\n  case !(f(x) < f(y)):\n    return -1;\n  default:\n    return 0;\n  }\n});\nexports.sum = sum = function(xs){\n  var result, i$, x, len$;\n  result = 0;\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (i$ in xs) {\n      x = xs[i$];\n      result += x;\n    }\n  } else {\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      result += x;\n    }\n  }\n  return result;\n};\nexports.product = product = function(xs){\n  var result, i$, x, len$;\n  result = 1;\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    for (i$ in xs) {\n      x = xs[i$];\n      result *= x;\n    }\n  } else {\n    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n      x = xs[i$];\n      result *= x;\n    }\n  }\n  return result;\n};\nexports.mean = mean = exports.average = average = function(xs){\n  return sum(xs) / length(xs);\n};\nexports.concat = concat = function(xss){\n  return fold(append, [], xss);\n};\nexports.concatMap = concatMap = curry$(function(f, xs){\n  return concat(map(f, xs));\n});\nexports.listToObj = listToObj = function(xs){\n  var result, i$, len$, x;\n  result = {};\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    result[x[0]] = x[1];\n  }\n  return result;\n};\nexports.maximum = maximum = function(xs){\n  return fold1(max, xs);\n};\nexports.minimum = minimum = function(xs){\n  return fold1(min, xs);\n};\nexports.scan = scan = exports.scanl = scanl = curry$(function(f, memo, xs){\n  var last, x;\n  last = memo;\n  if (toString$.call(xs).slice(8, -1) === 'Object') {\n    return [memo].concat((function(){\n      var i$, ref$, results$ = [];\n      for (i$ in ref$ = xs) {\n        x = ref$[i$];\n        results$.push(last = f(last, x));\n      }\n      return results$;\n    }()));\n  } else {\n    return [memo].concat((function(){\n      var i$, ref$, len$, results$ = [];\n      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {\n        x = ref$[i$];\n        results$.push(last = f(last, x));\n      }\n      return results$;\n    }()));\n  }\n});\nexports.scan1 = scan1 = exports.scanl1 = scanl1 = curry$(function(f, xs){\n  return scan(f, xs[0], xs.slice(1));\n});\nexports.scanr = scanr = curry$(function(f, memo, xs){\n  xs.reverse();\n  return scan(f, memo, xs).reverse();\n});\nexports.scanr1 = scanr1 = curry$(function(f, xs){\n  xs.reverse();\n  return scan(f, xs[0], xs.slice(1)).reverse();\n});\nexports.replicate = replicate = curry$(function(n, x){\n  var result, i;\n  result = [];\n  i = 0;\n  for (; i < n; ++i) {\n    result.push(x);\n  }\n  return result;\n});\nexports.take = take = curry$(function(n, xs){\n  switch (false) {\n  case !(n <= 0):\n    if (toString$.call(xs).slice(8, -1) === 'String') {\n      return '';\n    } else {\n      return [];\n    }\n    break;\n  case !!xs.length:\n    return xs;\n  default:\n    return xs.slice(0, n);\n  }\n});\nexports.drop = drop = curry$(function(n, xs){\n  switch (false) {\n  case !(n <= 0):\n    return xs;\n  case !!xs.length:\n    return xs;\n  default:\n    return xs.slice(n);\n  }\n});\nexports.splitAt = splitAt = curry$(function(n, xs){\n  return [take(n, xs), drop(n, xs)];\n});\nexports.takeWhile = takeWhile = curry$(function(p, xs){\n  var result, i$, len$, x;\n  if (!xs.length) {\n    return xs;\n  }\n  if (toString$.call(p).slice(8, -1) !== 'Function') {\n    p = objToFunc(p);\n  }\n  result = [];\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (!p(x)) {\n      break;\n    }\n    result.push(x);\n  }\n  if (toString$.call(xs).slice(8, -1) === 'String') {\n    return result.join('');\n  } else {\n    return result;\n  }\n});\nexports.dropWhile = dropWhile = curry$(function(p, xs){\n  var i, i$, len$, x;\n  if (!xs.length) {\n    return xs;\n  }\n  if (toString$.call(p).slice(8, -1) !== 'Function') {\n    p = objToFunc(p);\n  }\n  i = 0;\n  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {\n    x = xs[i$];\n    if (!p(x)) {\n      break;\n    }\n    ++i;\n  }\n  return drop(i, xs);\n});\nexports.span = span = curry$(function(p, xs){\n  return [takeWhile(p, xs), dropWhile(p, xs)];\n});\nexports.breakIt = breakIt = curry$(function(p, xs){\n  return span(compose$([not$, p]), xs);\n});\nexports.zip = zip = curry$(function(xs, ys){\n  var result, i, ref$, len$, zs, j, len1$, z, ref1$;\n  result = [];\n  for (i = 0, len$ = (ref$ = [xs, ys]).length; i < len$; ++i) {\n    zs = ref$[i];\n    for (j = 0, len1$ = zs.length; j < len1$; ++j) {\n      z = zs[j];\n      if (i === 0) {\n        result.push([]);\n      }\n      if ((ref1$ = result[j]) != null) {\n        ref1$.push(z);\n      }\n    }\n  }\n  return result;\n});\nexports.zipWith = zipWith = curry$(function(f, xs, ys){\n  var i$, ref$, len$, zs, results$ = [];\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  if (!xs.length || !ys.length) {\n    return [];\n  } else {\n    for (i$ = 0, len$ = (ref$ = zip.call(this, xs, ys)).length; i$ < len$; ++i$) {\n      zs = ref$[i$];\n      results$.push(f.apply(this, zs));\n    }\n    return results$;\n  }\n});\nexports.zipAll = zipAll = function(){\n  var xss, result, i, len$, xs, j, len1$, x, ref$;\n  xss = slice$.call(arguments);\n  result = [];\n  for (i = 0, len$ = xss.length; i < len$; ++i) {\n    xs = xss[i];\n    for (j = 0, len1$ = xs.length; j < len1$; ++j) {\n      x = xs[j];\n      if (i === 0) {\n        result.push([]);\n      }\n      if ((ref$ = result[j]) != null) {\n        ref$.push(x);\n      }\n    }\n  }\n  return result;\n};\nexports.zipAllWith = zipAllWith = function(f){\n  var xss, i$, ref$, len$, xs, results$ = [];\n  xss = slice$.call(arguments, 1);\n  if (toString$.call(f).slice(8, -1) !== 'Function') {\n    f = objToFunc(f);\n  }\n  if (!xss[0].length || !xss[1].length) {\n    return [];\n  } else {\n    for (i$ = 0, len$ = (ref$ = zipAll.apply(this, xss)).length; i$ < len$; ++i$) {\n      xs = ref$[i$];\n      results$.push(f.apply(this, xs));\n    }\n    return results$;\n  }\n};\nexports.compose = compose = function(){\n  var funcs;\n  funcs = slice$.call(arguments);\n  return function(){\n    var args, i$, ref$, len$, f;\n    args = arguments;\n    for (i$ = 0, len$ = (ref$ = funcs).length; i$ < len$; ++i$) {\n      f = ref$[i$];\n      args = [f.apply(this, args)];\n    }\n    return args[0];\n  };\n};\nexports.curry = curry = function(f){\n  return curry$(f);\n};\nexports.id = id = function(x){\n  return x;\n};\nexports.flip = flip = curry$(function(f, x, y){\n  return f(y, x);\n});\nexports.fix = fix = function(f){\n  return function(g, x){\n    return function(){\n      return f(g(g)).apply(null, arguments);\n    };\n  }(function(g, x){\n    return function(){\n      return f(g(g)).apply(null, arguments);\n    };\n  });\n};\nexports.lines = lines = function(str){\n  if (!str.length) {\n    return [];\n  }\n  return str.split('\\n');\n};\nexports.unlines = unlines = function(strs){\n  return strs.join('\\n');\n};\nexports.words = words = function(str){\n  if (!str.length) {\n    return [];\n  }\n  return str.split(/[ ]+/);\n};\nexports.unwords = unwords = function(strs){\n  return strs.join(' ');\n};\nexports.max = max = curry$(function(x, y){\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n});\nexports.min = min = curry$(function(x, y){\n  if (x > y) {\n    return y;\n  } else {\n    return x;\n  }\n});\nexports.negate = negate = function(x){\n  return -x;\n};\nexports.abs = abs = Math.abs;\nexports.signum = signum = function(x){\n  switch (false) {\n  case !(x < 0):\n    return -1;\n  case !(x > 0):\n    return 1;\n  default:\n    return 0;\n  }\n};\nexports.quot = quot = curry$(function(x, y){\n  return ~~(x / y);\n});\nexports.rem = rem = curry$(function(x, y){\n  return x % y;\n});\nexports.div = div = curry$(function(x, y){\n  return Math.floor(x / y);\n});\nexports.mod = mod = curry$(function(x, y){\n  var ref$;\n  return ((x) % (ref$ = y) + ref$) % ref$;\n});\nexports.recip = recip = function(x){\n  return 1 / x;\n};\nexports.pi = pi = Math.PI;\nexports.tau = tau = pi * 2;\nexports.exp = exp = Math.exp;\nexports.sqrt = sqrt = Math.sqrt;\nexports.ln = ln = Math.log;\nexports.pow = pow = curry$(function(x, y){\n  return Math.pow(x, y);\n});\nexports.sin = sin = Math.sin;\nexports.tan = tan = Math.tan;\nexports.cos = cos = Math.cos;\nexports.asin = asin = Math.asin;\nexports.acos = acos = Math.acos;\nexports.atan = atan = Math.atan;\nexports.atan2 = atan2 = curry$(function(x, y){\n  return Math.atan2(x, y);\n});\nexports.truncate = truncate = function(x){\n  return ~~x;\n};\nexports.round = round = Math.round;\nexports.ceiling = ceiling = Math.ceil;\nexports.floor = floor = Math.floor;\nexports.isItNaN = isItNaN = function(x){\n  return x !== x;\n};\nexports.even = even = function(x){\n  return x % 2 === 0;\n};\nexports.odd = odd = function(x){\n  return x % 2 !== 0;\n};\nexports.gcd = gcd = curry$(function(x, y){\n  var z;\n  x = Math.abs(x);\n  y = Math.abs(y);\n  while (y !== 0) {\n    z = x % y;\n    x = y;\n    y = z;\n  }\n  return x;\n});\nexports.lcm = lcm = curry$(function(x, y){\n  return Math.abs(Math.floor(x / gcd(x, y) * y));\n});\nexports.installPrelude = function(target){\n  var ref$;\n  if (!((ref$ = target.prelude) != null && ref$.isInstalled)) {\n    import$(target, exports);\n    target.prelude.isInstalled = true;\n  }\n};\nexports.prelude = exports;\nfunction curry$(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      curry$.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\nfunction in$(x, arr){\n  var i = 0, l = arr.length >>> 0;\n  while (i < l) if (x === arr[i++]) return true;\n  return false;\n}\nfunction compose$(fs){\n  return function(){\n    var i, args = arguments;\n    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }\n    return args[0];\n  };\n}\nfunction not$(x){ return !x; }\nfunction import$(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}\n//@ sourceURL=/node_modules/prelude-ls/prelude.js"
));

require.define("/src/media/scripts/entities.js",Function(['require','module','exports','__dirname','__filename','process','global'],"(function(){\n  var λ, boo, $, ref$, setHtml, clone, marked, mappings, renderAll, makeHtml, renderSignature, makeRepositoryLink, renderAuthor, Code, Entity, Group, Type, Function, Module, Data, Class, _Object;\n  λ = require('prelude-ls');\n  boo = require('boo');\n  $ = require('clotho/src/browser').builder;\n  ref$ = require('moros')(), setHtml = ref$.setHtml, clone = ref$.clone;\n  marked = require('marked');\n  mappings = {};\n  clone = clone(true);\n  renderAll = λ.map(function(it){\n    return it.render(void 8);\n  });\n  makeHtml = function(x){\n    return setHtml(x, $('.html-container'));\n  };\n  renderSignature = function(x){\n    return $('.signature', x);\n  };\n  makeRepositoryLink = function(repository, file, line, endLine){\n    var filename;\n    filename = line ? file + \":\" + line + \"-\" + endLine : file;\n    switch (false) {\n    case !/github.com/.test(repository):\n      return $('a.link', {\n        href: repository + \"/blob/master/\" + file + \"#L\" + (line || 1) + \"-\" + (endLine || 1)\n      }, filename);\n    default:\n      return filename;\n    }\n  };\n  renderAuthor = function(author){\n    switch (false) {\n    case !author.website:\n      return $('li.author', $('a.link', {\n        href: author.website\n      }, author.name));\n    case !author.email:\n      return $('li.author', $('a.link', {\n        href: \"mailto:\" + author.email\n      }, author.name));\n    case !author.name:\n      return $('li.author', author.name);\n    }\n  };\n  Code = boo.Base.derive({\n    init: function(x){\n      this.language = x.language;\n      this.line = x.line;\n      this.endLine = x['end-line'] || x.line;\n      this.file = x.file;\n      this.repository = x.repository;\n      this.authors = x.authors;\n      this.licence = x.licence;\n      this.code = x.code;\n      return this.copyright = x.copyright;\n    },\n    render: function(){\n      return $('.source-code', $('h3.section-title', 'Source'), this.repository ? $('.repository-meta', $('strong', 'Repository: '), $('a.link', {\n        href: this.repository\n      }, this.repository)) : void 8, this.file ? $('.file-meta', $('strong', 'File: '), makeRepositoryLink(this.repository, this.file, this.line, this.endLine)) : void 8, this.code ? $('pre.prettify', $('code', this.code)) : void 8, this.authors ? $('.licence-meta', this.copyright ? $('.copyright', this.copyright) : void 8, $('ul.authors', λ.map(renderAuthor, this.authors)), this.licence ? $('.licence', 'Licensed under ', this.licence) : void 8) : void 8);\n    }\n  });\n  Entity = boo.Base.derive({\n    kind: 'entity',\n    init: function(x){\n      this.id = x.id;\n      this.name = x.name;\n      this.text = makeHtml(marked(x.text || ''));\n      this.markdown = x.text || '';\n      this.examples = λ.map(compose$([makeHtml, marked]), x.examples || []);\n      this.parentId = x.parent;\n      this.parent = null;\n      return this.children = [];\n    },\n    summary: function(){\n      return clone(this.text);\n    },\n    assimilate: function(x){\n      if (x.parent) {\n        x.parent.remove(x);\n      }\n      x.parent = this;\n      return this.children.push(x);\n    },\n    remove: function(x){\n      var p;\n      x.parent = null;\n      p = this.children.indexOf(x);\n      if (p > -1) {\n        return this.children.splice(p, 1);\n      }\n    },\n    renderAsItem: function(){\n      return [];\n    },\n    render: function(){\n      return $(\".item.kind-\" + this.kind + \".child-no-\" + this.children.length, this.renderAsItem(), $(\".children\", renderAll(this.children)));\n    },\n    page: function(){\n      return $(\".page.kind-\" + this.kind, $('h2.title', this.name), $('.description', clone(this.text)));\n    }\n  });\n  Group = Entity.derive({\n    kind: 'group',\n    init: function(x){\n      return Entity.init.call(this, x);\n    },\n    renderAsItem: function(){\n      return $('.group-title', this.name);\n    }\n  });\n  Type = Entity.derive({\n    kind: 'type',\n    init: function(x){\n      Entity.init.call(this, x);\n      this.code = Code.make(x);\n      return this.signatures = x.signatures || [];\n    },\n    fullName: function(){\n      return this.name;\n    },\n    representation: function(){\n      return [$('.name', this.name), this.signatures.length ? $('.signature', $('.default-signature', this.signatures[0]), this.signatures.length > 1 ? $('.signature-count', \"+\" + (this.signatures.length - 1)) : void 8) : void 8];\n    },\n    renderAsItem: function(){\n      return $('.type-description.jsk-actionable-item', {\n        'data-id': this.id\n      }, $('.representation', this.representation()), $('.description', this.summary()));\n    },\n    page: function(){\n      return $(\".page.kind-\" + this.kind, $('h2.title', this.fullName()), $('.signatures', λ.map(renderSignature, this.signatures)), $('.description', clone(this.text)), this.code.code ? this.code.render() : void 8, this.examples.length ? $('.examples-section', $('h3.section-title', 'Examples'), this.examples) : void 8, this.children.length ? $('.children', $('h3.section-title', 'See also'), renderAll(this.children)) : void 8);\n    }\n  });\n  Function = Type.derive({\n    kind: 'function'\n  });\n  Module = Type.derive({\n    kind: 'module'\n  });\n  Data = Type.derive({\n    kind: 'data'\n  });\n  Class = Type.derive({\n    kind: 'class'\n  });\n  _Object = Type.derive({\n    kind: 'object'\n  });\n  mappings[''] = Entity;\n  mappings['group'] = Group;\n  mappings['type'] = Type;\n  mappings['module'] = Module;\n  mappings['function'] = Function;\n  mappings['object'] = _Object;\n  mappings['class'] = Class;\n  mappings['data'] = Data;\n  module.exports = {\n    Entity: Entity,\n    Group: Group,\n    Type: Type,\n    mappings: mappings\n  };\n  function compose$(fs){\n    return function(){\n      var i, args = arguments;\n      for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }\n      return args[0];\n    };\n  }\n}).call(this);\n\n//@ sourceURL=/src/media/scripts/entities.js"
));

require.define("/node_modules/boo/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./lib/boo.js\"}\n//@ sourceURL=/node_modules/boo/package.json"
));

require.define("/node_modules/boo/lib/boo.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/// boo.js --- Base primitives for prototypical OO\n//\n// Copyright (c) 2011 Quildreen \"Sorella\" Motta <quildreen@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module boo\nvoid function(root, exports) {\n\n  //// -- Aliases -------------------------------------------------------------\n  var slice        = [].slice\n  var keys         = Object.keys\n  var inherit      = Object.create\n  var define       = Object.defineProperty\n  var descriptor   = Object.getOwnPropertyDescriptor\n  var has_getter_p = function () {\n                       try {\n                         return true === Object.create( {}\n                                                      , { x: { get:\n                                                               function(){\n                                                                 return true }}}).x }\n                       catch(e){ return false }}()\n\n\n  \f\n  //// -- Interfaces ----------------------------------------------------------\n\n  ///// Interface DataObject\n  // DataObject :: { \"to_data\" -> () -> Object }\n\n  ///// Interface Mixin\n  // Mixin :: Object | DataObject\n\n  \f\n  //// -- Helpers -------------------------------------------------------------\n\n  ///// Function copy_property\n  // :internal:\n  // Copies a property from ``source`' to ``target`'.\n  //\n  // copy_property! :: Object, target:Object*, String -> target\n  function copy_property(source, target, property) {\n    !has_getter_p?     target[property] = source[property]\n    : /* otherwise */  define(target, property, descriptor(source, property))\n\n    return target\n  }\n\n  ///// Function data_obj_p\n  // :internal:\n  // Checks if the given subject matches the ``DataObject`` interface\n  //\n  // data_obj_p :: Any -> Bool\n  function data_obj_p(subject) {\n    return subject != null\n    &&     typeof subject.to_data == 'function' }\n\n\n  ///// Function resolve_mixins\n  // :internal:\n  // Returns the proper object for the given mixin.\n  //\n  // resolve_mixin :: Mixin -> Object\n  function resolve_mixin(subject) {\n    return data_obj_p(subject)?  subject.to_data()\n    :      /* otherwise */       subject }\n\n\n  ///// Function fast_extend\n  // :internal:\n  // Extends the target object with the provided mixins, using a\n  // right-most precedence rule — when a there's a property conflict, the\n  // property defined in the last object wins.\n  //\n  // ``DataObject``s are properly handled by the ``resolve_mixin``\n  // function.\n  //\n  // :warning: low-level\n  //    This function is not meant to be called directly from end-user\n  //    code, use the ``extend`` function instead.\n  //\n  // fast_extend! :: target:Object*, [Mixin] -> target\n  function fast_extend(object, mixins) {\n    var i, j, len, mixin, props, key\n    for (i = 0, len = mixins.length; i < len; ++i) {\n      mixin = resolve_mixin(mixins[i])\n      props = keys(mixin)\n      for (j = props.length; j--;) {\n        key         = props[j]\n        copy_property(mixin, object, key) }}\n\n    return object }\n\n\n  \f\n  //// -- Basic primitives ----------------------------------------------------\n\n  ///// Function extend\n  // Extends the target object with the provided mixins, using a\n  // right-most precedence rule.\n  //\n  // :see-also:\n  //   - ``fast_extend`` — lower level function.\n  //   - ``merge``       — pure version.\n  //\n  // extend! :: target:Object*, Mixin... -> target\n  function extend(target) {\n    return fast_extend(target, slice.call(arguments, 1)) }\n\n\n  ///// Function merge\n  // Creates a new object that merges the provided mixins, using a\n  // right-most precedence rule.\n  //\n  // :see-also:\n  //   - ``extend`` — impure version.\n  //\n  // merge :: Mixin... -> Object\n  function merge() {\n    return fast_extend({}, arguments) }\n\n\n  ///// Function derive\n  // Creates a new object inheriting from the given prototype and extends\n  // the new instance with the provided mixins.\n  //\n  // derive :: proto:Object, Mixin... -> Object <| proto\n  function derive(proto) {\n    return fast_extend(inherit(proto), slice.call(arguments, 1)) }\n\n\n  ///// Function make\n  // Constructs a new instance of the given object.\n  //\n  // If the object provides an ``init`` function, that function is\n  // invoked to do initialisation on the new instance.\n  //\n  // make :: proto:Object, Any... -> Object <| proto\n  function make(base) {\n    return Base.make.apply(base, slice.call(arguments, 1)) }\n\n\n  \f\n  //// -- Root object ---------------------------------------------------------\n\n  ///// Object Base\n  // The root object for basing all the OOP code. Provides the previous\n  // primitive combinators in an easy and OOP-way.\n  var Base = {\n\n    ////// Function make\n    // Constructs new instances of the object the function is being\n    // applied to.\n    //\n    // If the object provides an ``init`` function, that function is\n    // invoked to do initialisation on the new instance.\n    //\n    // make :: @this:Object, Any... -> Object <| this\n    make:\n    function _make() {\n      var result = inherit(this)\n      if (typeof result.init == 'function')\n        result.init.apply(result, arguments)\n\n      return result }\n\n    ////// Function derive\n    // Constructs a new object that inherits from the object this function\n    // is being applied to, and extends it with the provided mixins.\n    //\n    // derive :: @this:Object, Mixin... -> Object <| this\n  , derive:\n    function _derive() {\n      return fast_extend(inherit(this), arguments) }}\n\n\n  \f\n  //// -- Exports -------------------------------------------------------------\n  exports.extend   = extend\n  exports.merge    = merge\n  exports.derive   = derive\n  exports.make     = make\n  exports.Base     = Base\n  exports.internal = { data_obj_p    : data_obj_p\n                     , fast_extend   : fast_extend\n                     , resolve_mixin : resolve_mixin\n                     , copy_property : copy_property\n                     }\n\n}\n( this\n, typeof exports == 'undefined'?  this.boo = this.boo || {}\n  /* otherwise, yay modules! */:  exports\n)\n\n//@ sourceURL=/node_modules/boo/lib/boo.js"
));

require.define("/node_modules/clotho/src/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/// browser.js --- DOM building for Browser environments\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar builder = require('./core')({\n  html: function(s){ return document.createElement(s) }\n, text: function(s){ return document.createTextNode(s) } })\n\nmodule.exports = { builder:      builder.builder\n                 , make_element: builder.make_element }\n//@ sourceURL=/node_modules/clotho/src/browser.js"
));

require.define("/node_modules/clotho/src/core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/// core.js --- The barebones\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = function(generator) {\n\n  var keys    = Object.keys\n  var slice   = [].slice\n  var proto   = Object.getPrototypeOf\n  var array_p = Array.isArray\n\n\n  function string_p(subject) {\n    return typeof subject == 'string' }\n\n\n  function object_p(subject) {\n    return Object(subject) === subject\n    &&     proto(subject) === Object.prototype }\n\n\n  function parse_selector(text) {\n    var i, component, type\n    var components = text.split(/(?=#|\\.)/)\n    var selector   = { classes: [], id: '' }\n    for (i = components.length; i--;) {\n      component = components[i]\n      type      = kind(component)\n\n        type == 'class'?  selector.classes.push(component.slice(1))\n      : type == 'id'?     selector.id  = component.slice(1)\n      : /* otherwise */   selector.tag = component }\n\n    return selector }\n\n\n  function kind(selector) {\n    return selector.charAt(0) == '#'?  'id'\n    :      selector.charAt(0) == '.'?  'class'\n    :      /* otherwise */             'tag' }\n\n\n  function set_properties(element, properties) {\n    var i, len\n    var names = keys(properties)\n    for (i = 0, len = names.length; i < len; ++i)\n      element.setAttribute(names[i], properties[names[i]])\n    return element }\n\n\n  function append_children(element, children) {\n    var i, len, child\n    for (i = 0, len = children.length; i < len; ++i) {\n      child = children[i]\n        array_p(child)?  append_children(element, child)\n      : child != null?   element.appendChild(make_node(child))\n      : /* otherwise */  null }\n    return element }\n\n\n  function make_node(subject) {\n    return string_p(subject)?  generator.text(subject)\n    :      /* otherwise */     subject }\n\n\n  function make_element(selector, properties, children) {\n    selector = parse_selector(selector)\n    var element = generator.html(selector.tag || 'div')\n    if (selector.id)       element.setAttribute('id', selector.id)\n    if (selector.classes)  element.setAttribute('class', selector.classes.join(' '))\n\n    set_properties(element, properties || {})\n    append_children(element, children  || [])\n    return element }\n\n\n  function builder(selector) {\n    var properties\n    var children = slice.call(arguments, 1)\n    if (object_p(children[0]))  properties = children.shift()\n    return make_element(selector, properties, children) }\n\n  return { make_element : make_element\n         , builder      : builder }\n}\n//@ sourceURL=/node_modules/clotho/src/core.js"
));

require.define("/node_modules/moros/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./lib/index.js\"}\n//@ sourceURL=/node_modules/moros/package.json"
));

require.define("/node_modules/moros/lib/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** index.ls --- A minimal and modular DOOM library\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar map, each, merge, __ref;\n__ref = require('./utils'), map = __ref.map, each = __ref.each;\nmerge = function(xs){\n  var result, source, __i, __len;\n  result = {};\n  for (__i = 0, __len = xs.length; __i < __len; ++__i) {\n    source = xs[__i];\n    __import(result, source);\n  }\n  return result;\n};\nmodule.exports = function(engine, events){\n  return merge([\n    require('./query')(\n    engine), require('./manipulation'), require('./reflection'), require('./presentation'), require('./event')(\n    events), {\n      map: map,\n      each: each\n    }\n  ]);\n};\nfunction __import(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}\n//@ sourceURL=/node_modules/moros/lib/index.js"
));

require.define("/node_modules/moros/lib/utils.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** utils.ls --- Shared utilities\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar id, k, head, tail, sequenceP, asSequence, toArray, each, map;\nid = function(x){\n  return x;\n};\nk = function(x){\n  return function(){\n    return x;\n  };\n};\nhead = function(xs){\n  return xs[0];\n};\ntail = function(xs){\n  return xs.slice(1);\n};\nsequenceP = function(x){\n  return x && x.length >= 0;\n};\nasSequence = function(x){\n  switch (false) {\n  case !sequenceP(x):\n    return x;\n  default:\n    return [x];\n  }\n};\ntoArray = function(xs){\n  var x, __i, __len, __results = [];\n  for (__i = 0, __len = xs.length; __i < __len; ++__i) {\n    x = xs[__i];\n    __results.push(x);\n  }\n  return __results;\n};\neach = __curry(function(f, xs){\n  var xs, i, x, __len;\n  xs = asSequence(xs);\n  for (i = 0, __len = xs.length; i < __len; ++i) {\n    x = xs[i];\n    f(x);\n  }\n  return xs;\n});\nmap = __curry(function(f, xs){\n  var x, __i, __ref, __len, __results = [];\n  for (__i = 0, __len = (__ref = asSequence(xs)).length; __i < __len; ++__i) {\n    x = __ref[__i];\n    __results.push(f(x));\n  }\n  return __results;\n});\nmodule.exports = {\n  asSequence: asSequence,\n  toArray: toArray,\n  head: head,\n  tail: tail,\n  id: id,\n  k: k,\n  each: each,\n  map: map\n};\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/node_modules/moros/lib/utils.js"
));

require.define("/node_modules/moros/lib/query.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** query.ls --- Selects a set of nodes using CSS selectors\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nmodule.exports = function(engine){\n  var head, toArray, query, queryOne;\n  head = require('./utils').head;\n  toArray = Function.call.bind([].slice);\n  query = function(selector, context){\n    var context;\n    context == null && (context = document);\n    return toArray(context.querySelectorAll(selector));\n  };\n  queryOne = function(selector, context){\n    var context;\n    context == null && (context = document);\n    return context.querySelector(selector);\n  };\n  if (engine) {\n    return {\n      query: engine,\n      queryOne: function(selector, context){\n        return head(engine(selector, context));\n      }\n    };\n  } else {\n    return {\n      query: query,\n      queryOne: queryOne\n    };\n  }\n};\n//@ sourceURL=/node_modules/moros/lib/query.js"
));

require.define("/node_modules/moros/lib/manipulation.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** manipulation.ls --- Manipulates DOOM trees\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar map, each, head, tail, asSequence, append, prepend, insertBefore, insertAfter, remove, detach, replace, wrap, clear, clone, __ref;\n__ref = require('./utils'), map = __ref.map, each = __ref.each, head = __ref.head, tail = __ref.tail, asSequence = __ref.asSequence;\nappend = __curry(function(parent, xs){\n  return each(function(it){\n    return parent.appendChild(it);\n  })(\n  xs);\n});\nprepend = __curry(function(parent, xs){\n  return each(function(it){\n    switch (false) {\n    case !parent.firstChild:\n      return insertBefore(parent.firstChild, it);\n    default:\n      return parent.appendChild(it);\n    }\n  })(\n  xs);\n});\ninsertBefore = __curry(function(x, xs){\n  return each(function(it){\n    return x.parentNode.insertBefore(it, x);\n  })(\n  xs);\n});\ninsertAfter = __curry(function(x, xs){\n  return each(function(it){\n    return x.parentNode.insertBefore(it, x.nextSibling);\n  })(\n  xs);\n});\nremove = __curry(function(parent, xs){\n  return each(function(it){\n    return parent.removeChild(it);\n  })(\n  xs);\n});\ndetach = each(function(it){\n  return it.parentNode.removeChild(it);\n});\nreplace = __curry(function(node, xs){\n  var xs;\n  xs = asSequence(xs);\n  node.parentNode.replaceChild(head(xs), node);\n  insertAfter(head(xs), tail(xs));\n  return xs;\n});\nwrap = __curry(function(node, x){\n  insertBefore(node, x);\n  return x.appendChild(node);\n});\nclear = each(function(it){\n  while (it.firstChild) {\n    it.removeChild(it.firstChild);\n  }\n});\nclone = __curry(function(deep, xs){\n  return map(function(it){\n    return it.cloneNode(deep);\n  })(\n  xs);\n});\nmodule.exports = {\n  append: append,\n  prepend: prepend,\n  insertBefore: insertBefore,\n  insertAfter: insertAfter,\n  remove: remove,\n  detach: detach,\n  replace: replace,\n  clear: clear,\n  wrap: wrap,\n  clone: clone\n};\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/node_modules/moros/lib/manipulation.js"
));

require.define("/node_modules/moros/lib/reflection.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** reflection.ls --- Provides information about nodes.\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar each, map, toArray, TEXT, attributes, attribute, setAttribute, text, setText, html, setHtml, __ref;\n__ref = require('./utils'), each = __ref.each, map = __ref.map, toArray = __ref.toArray;\nTEXT = (function(e){\n  switch (false) {\n  case !('innerText' in e):\n    return 'innerText';\n  default:\n    return 'textContent';\n  }\n}.call(this, document.createElement('div')));\nattributes = map(function(it){\n  return toArray(it.attributes);\n});\nattribute = __curry(function(name, xs){\n  return map(function(it){\n    return it.getAttribute(name);\n  })(\n  xs);\n});\nsetAttribute = __curry(function(name, value, xs){\n  return each(function(it){\n    switch (false) {\n    case value != null:\n      return it.removeAttribute(name);\n    default:\n      return it.setAttribute(name, value);\n    }\n  })(\n  xs);\n});\ntext = map(function(it){\n  return it[TEXT];\n});\nsetText = __curry(function(value, xs){\n  return each(function(it){\n    return it[TEXT] = value;\n  })(\n  xs);\n});\nhtml = map(function(it){\n  return it.innerHTML;\n});\nsetHtml = __curry(function(value, xs){\n  return each(function(it){\n    return it.innerHTML = value;\n  })(\n  xs);\n});\nmodule.exports = {\n  attributes: attributes,\n  attribute: attribute,\n  setAttribute: setAttribute,\n  text: text,\n  setText: setText,\n  html: html,\n  setHtml: setHtml\n};\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/node_modules/moros/lib/reflection.js"
));

require.define("/node_modules/moros/lib/presentation.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** presentation.ls --- Core visual presentation handling\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar map, each, arrayP, getComputedStyle, makeClassRe, normaliseClasses, style, computedStyle, setStyle, classes, addClass, removeClass, hasClassP, toggleClass, specifyClassState, __ref;\n__ref = require('./utils'), map = __ref.map, each = __ref.each;\narrayP = Array.isArray;\ngetComputedStyle = (function(e){\n  switch (false) {\n  case !('currentStyle' in e):\n    return function(it){\n      return it.currentStyle;\n    };\n  default:\n    return function(it, state){\n      return it.ownerDocument.defaultView.getComputedStyle(it, state);\n    };\n  }\n}.call(this, document.createElement('div')));\nmakeClassRe = function(name){\n  var escape;\n  escape = function(re){\n    return re.trim().replace(/([^\\w\\s])/g, '\\\\$1').replace(/\\s+/, '|');\n  };\n  return new RegExp(\"\\\\s*\\\\b(\" + escape(normaliseClasses(name)) + \")\\\\b\\\\s*\", 'gi');\n};\nnormaliseClasses = function(it){\n  switch (false) {\n  case !arrayP(it):\n    return it.join(' ');\n  default:\n    return String(it);\n  }\n};\nstyle = __curry(function(name, xs){\n  return map(function(it){\n    return it.style[name];\n  })(\n  xs);\n});\ncomputedStyle = __curry(function(name, xs){\n  return map(function(it){\n    return getComputedStyle(it)[name];\n  })(\n  xs);\n});\nsetStyle = __curry(function(name, value, xs){\n  return each(function(it){\n    return it.style[name] = value;\n  })(\n  xs);\n});\nclasses = map(function(it){\n  return it.className.trim().split(/\\s+/);\n});\naddClass = __curry(function(name, xs){\n  return each(function(it){\n    removeClass(name, it);\n    return it.className += \" \" + normaliseClasses(name);\n  })(\n  xs);\n});\nremoveClass = __curry(function(name, xs){\n  var re;\n  re = makeClassRe(name);\n  return each(function(it){\n    return it.className = it.className.replace(re, '');\n  })(\n  xs);\n});\nhasClassP = __curry(function(name, xs){\n  var re;\n  re = makeClassRe(name);\n  return map(function(it){\n    return re.test(it.className);\n  })(\n  xs);\n});\ntoggleClass = __curry(function(name, xs){\n  var hasP;\n  hasP = hasClassP(name);\n  debugger;\n  return each(function(it){\n    switch (false) {\n    case !hasP(it)[0]:\n      return removeClass(name, it);\n    default:\n      return addClass(name, it);\n    }\n  })(\n  xs);\n});\nspecifyClassState = __curry(function(name, shouldAddP, xs){\n  return each(function(it){\n    switch (false) {\n    case !shouldAddP:\n      return addClass(name, it);\n    default:\n      return removeClass(name, it);\n    }\n  })(\n  xs);\n});\nmodule.exports = {\n  style: style,\n  computedStyle: computedStyle,\n  setStyle: setStyle,\n  classes: classes,\n  addClass: addClass,\n  removeClass: removeClass,\n  hasClassP: hasClassP,\n  toggleClass: toggleClass,\n  specifyClassState: specifyClassState\n};\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/node_modules/moros/lib/presentation.js"
));

require.define("/node_modules/moros/lib/event.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/** event.ls --- Manages events on DOOM nodes\n *\n * Version: 0.3.5\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nmodule.exports = function(event){\n  var each, e, hasP, w3cListen, w3cRemove, ieListen, ieRemove, listen, deafen;\n  each = require('./utils').each;\n  e = document.createElement('div');\n  hasP = function(key){\n    return key in e;\n  };\n  w3cListen = __curry(function(event, handler, xs){\n    return each(function(it){\n      return it.addEventListener(event, handler, false);\n    })(\n    xs);\n  });\n  w3cRemove = __curry(function(event, handler, xs){\n    return each(function(it){\n      return it.removeEventListener(event, handler, false);\n    })(\n    xs);\n  });\n  ieListen = __curry(function(event, handler, xs){\n    return each(function(it){\n      return it.attachEvent(\"on\" + event, handler);\n    })(\n    xs);\n  });\n  ieRemove = __curry(function(event, handler, xs){\n    return each(function(it){\n      return it.detachEvent(\"on\" + event, handler);\n    })(\n    xs);\n  });\n  listen = (function(){\n    switch (false) {\n    case !hasP('addEventListener'):\n      return w3cListen;\n    default:\n      return ieListen;\n    }\n  }());\n  deafen = (function(){\n    switch (false) {\n    case !hasP('removeEventListener'):\n      return w3cRemove;\n    default:\n      return ieRemove;\n    }\n  }());\n  if (event) {\n    return event;\n  } else {\n    return {\n      listen: listen,\n      deafen: deafen\n    };\n  }\n};\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/node_modules/moros/lib/event.js"
));

require.define("/node_modules/marked/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./lib/marked.js\"}\n//@ sourceURL=/node_modules/marked/package.json"
));

require.define("/node_modules/marked/lib/marked.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/**\n * marked - a markdown parser\n * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){3,} *\\n*/,\n  blockquote: /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment|closed|closing) *(?:\\n{2,}|\\s*$)/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', /\\n+(?=(?: *[-*_]){3,} *(?:\\n+|$))/)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,}) *(\\w+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!' + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3]\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: isFinite(cap[2])\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      // Get bullet.\n      if (this.options.smartLists) {\n        bull = block.bullet.exec(cap[0])[0];\n      }\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i+1])[0];\n          if (bull !== b && !(bull[1] === '.' && b[1] === '.')) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item[item.length-1] === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: cap[1] === 'pre',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if (top && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1][cap[1].length-1] === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([^\\s]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1][6] === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += '<a href=\"'\n        + href\n        + '\">'\n        + text\n        + '</a>';\n      continue;\n    }\n\n    // url (gfm)\n    if (cap = this.rules.url.exec(src)) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += '<a href=\"'\n        + href\n        + '\">'\n        + text\n        + '</a>';\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? escape(cap[0])\n        : cap[0];\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0][0];\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      out += this.outputLink(cap, link);\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += '<strong>'\n        + this.output(cap[2] || cap[1])\n        + '</strong>';\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += '<em>'\n        + this.output(cap[2] || cap[1])\n        + '</em>';\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += '<code>'\n        + escape(cap[2], true)\n        + '</code>';\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += '<br>';\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += '<del>'\n        + this.output(cap[1])\n        + '</del>';\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += escape(cap[0]);\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  if (cap[0][0] !== '!') {\n    return '<a href=\"'\n      + escape(link.href)\n      + '\"'\n      + (link.title\n      ? ' title=\"'\n      + escape(link.title)\n      + '\"'\n      : '')\n      + '>'\n      + this.output(cap[1])\n      + '</a>';\n  } else {\n    return '<img src=\"'\n      + escape(link.href)\n      + '\" alt=\"'\n      + escape(cap[1])\n      + '\"'\n      + (link.title\n      ? ' title=\"'\n      + escape(link.title)\n      + '\"'\n      : '')\n      + '>';\n  }\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options) {\n  var parser = new Parser(options);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length-1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return '<hr>\\n';\n    }\n    case 'heading': {\n      return '<h'\n        + this.token.depth\n        + '>'\n        + this.inline.output(this.token.text)\n        + '</h'\n        + this.token.depth\n        + '>\\n';\n    }\n    case 'code': {\n      if (this.options.highlight) {\n        var code = this.options.highlight(this.token.text, this.token.lang);\n        if (code != null && code !== this.token.text) {\n          this.token.escaped = true;\n          this.token.text = code;\n        }\n      }\n\n      if (!this.token.escaped) {\n        this.token.text = escape(this.token.text, true);\n      }\n\n      return '<pre><code'\n        + (this.token.lang\n        ? ' class=\"'\n        + this.options.langPrefix\n        + this.token.lang\n        + '\"'\n        : '')\n        + '>'\n        + this.token.text\n        + '</code></pre>\\n';\n    }\n    case 'table': {\n      var body = ''\n        , heading\n        , i\n        , row\n        , cell\n        , j;\n\n      // header\n      body += '<thead>\\n<tr>\\n';\n      for (i = 0; i < this.token.header.length; i++) {\n        heading = this.inline.output(this.token.header[i]);\n        body += this.token.align[i]\n          ? '<th align=\"' + this.token.align[i] + '\">' + heading + '</th>\\n'\n          : '<th>' + heading + '</th>\\n';\n      }\n      body += '</tr>\\n</thead>\\n';\n\n      // body\n      body += '<tbody>\\n'\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n        body += '<tr>\\n';\n        for (j = 0; j < row.length; j++) {\n          cell = this.inline.output(row[j]);\n          body += this.token.align[j]\n            ? '<td align=\"' + this.token.align[j] + '\">' + cell + '</td>\\n'\n            : '<td>' + cell + '</td>\\n';\n        }\n        body += '</tr>\\n';\n      }\n      body += '</tbody>\\n';\n\n      return '<table>\\n'\n        + body\n        + '</table>\\n';\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return '<blockquote>\\n'\n        + body\n        + '</blockquote>\\n';\n    }\n    case 'list_start': {\n      var type = this.token.ordered ? 'ol' : 'ul'\n        , body = '';\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return '<'\n        + type\n        + '>\\n'\n        + body\n        + '</'\n        + type\n        + '>\\n';\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return '<li>'\n        + body\n        + '</li>\\n';\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return '<li>'\n        + body\n        + '</li>\\n';\n    }\n    case 'html': {\n      return !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n    }\n    case 'paragraph': {\n      return '<p>'\n        + this.inline.output(this.token.text)\n        + '</p>\\n';\n    }\n    case 'text': {\n      return '<p>'\n        + this.parseText()\n        + '</p>\\n';\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Marked\n */\n\nfunction marked(src, opt) {\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-'\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (typeof exports === 'object') {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n\n//@ sourceURL=/node_modules/marked/lib/marked.js"
));

require.define("/src/media/scripts/scope.js",Function(['require','module','exports','__dirname','__filename','process','global'],"(function(){\n  var λ, entities, ref$, detach, listen, clear, query, append, addClass, removeClass, specifyClassState, each, $, bindings, top, matchesP, findTarget, activate, deactivate, rendered, makeEntity, makeBinding, resolveCrossReference, topLevelP, load, updateRender, doTransition, searchQuery, searchTimer, doSearch;\n  λ = require('prelude-ls');\n  entities = require('./entities');\n  ref$ = require('moros')(), detach = ref$.detach, listen = ref$.listen, clear = ref$.clear, query = ref$.query, append = ref$.append, addClass = ref$.addClass, removeClass = ref$.removeClass, specifyClassState = ref$.specifyClassState, each = ref$.each;\n  $ = require('clotho/src/browser').builder;\n  bindings = {};\n  top = [];\n  matchesP = (function(el){\n    return el.matchesSelector || el.oMatchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector;\n  }.call(this, document.createElement('div')));\n  findTarget = curry$(function(selector, parent, x){\n    while (x !== parent) {\n      if (matchesP.call(x, selector)) {\n        return x;\n      }\n      x = x.parentElement;\n    }\n    return null;\n  });\n  activate = addClass('active');\n  deactivate = removeClass('active');\n  rendered = λ.map(function(it){\n    return it.render(void 8);\n  });\n  makeEntity = function(x){\n    switch (false) {\n    case !(x.kind in entities.mappings):\n      return entities.mappings[x.kind].make(x);\n    default:\n      throw new Error(\"Unknow entity type \" + x.kind);\n    }\n  };\n  makeBinding = function(x){\n    return bindings[x.id] = x;\n  };\n  resolveCrossReference = function(x){\n    var parent;\n    parent = bindings[x.parentId];\n    if (parent) {\n      parent.assimilate(x);\n    }\n    return x;\n  };\n  topLevelP = function(it){\n    return it.parent === null;\n  };\n  load = function(xs){\n    var ys, as;\n    ys = λ.map(compose$([makeBinding, makeEntity]), xs);\n    λ.map(resolveCrossReference)(\n    ys);\n    as = λ.values(bindings);\n    top.length = 0;\n    top.push.apply(top, as.filter(topLevelP));\n    return updateRender(top);\n  };\n  updateRender = function(xs){\n    var entityList;\n    entityList = query('#entity-list')[0];\n    clear(entityList);\n    return append(entityList, rendered(xs));\n  };\n  doTransition = function(){\n    window.scrollTo(0, 0);\n    addClass('in-transition', query('body'));\n    return setTimeout(function(){\n      return removeClass('in-transition', query('body'));\n    }, 600);\n  };\n  listen('click', function(ev){\n    var el, id, entity, p;\n    el = findTarget('.jsk-actionable-item', ev.currentTarget, ev.target);\n    if (el) {\n      ev.preventDefault();\n      id = el.getAttribute('data-id');\n      entity = bindings[id];\n      if (entity) {\n        append(query('#viewport')[0], p = $('li.context.entity-details', $('.back-button'), entity.page()));\n        deactivate(query('.context'));\n        activate(p);\n        addClass('prettyprint', query('pre', p));\n        prettyPrint(void 8, p);\n        return doTransition();\n      }\n    }\n  })(\n  query('#viewport'));\n  listen('click', function(ev){\n    var el, context;\n    el = findTarget('.context > .back-button', ev.currentTarget, ev.target);\n    if (el) {\n      ev.preventDefault();\n      context = el.parentElement;\n      deactivate(context);\n      activate(context.previousElementSibling);\n      setTimeout(function(){\n        return detach(context);\n      }, 500);\n      return doTransition();\n    }\n  })(\n  query('#viewport'));\n  searchQuery = query('#search-query')[0];\n  searchTimer = null;\n  listen('focus', function(ev){\n    return activate(searchQuery.parentElement);\n  })(\n  searchQuery);\n  listen('blur', function(ev){\n    return deactivate(searchQuery.parentElement);\n  })(\n  searchQuery);\n  listen('keyup', function(ev){\n    clearTimeout(searchTimer);\n    return setTimeout(doSearch, 1000);\n  })(\n  searchQuery);\n  doSearch = function(){\n    var value;\n    value = new RegExp(searchQuery.value.replace(/\\s*/g, '').replace(/(\\W)/g, '\\\\s*\\\\$1\\\\s*'), 'i');\n    return each(function(x){\n      var entity, visible;\n      entity = bindings[x.getAttribute('data-id')];\n      if (entity) {\n        visible = value.test(entity.id) || value.test(entity.name) || value.test(entity.markdown) || value.test((entity.signatures || []).join('\\n'));\n        return specifyClassState('hidden', !visible, x);\n      }\n    })(\n    query('#entity-list .jsk-actionable-item'));\n  };\n  window.papyr = {\n    load: load,\n    bindings: bindings,\n    top: top\n  };\n  function curry$(f, bound){\n    var context,\n    _curry = function(args) {\n      return f.length > 1 ? function(){\n        var params = args ? args.concat() : [];\n        context = bound ? context || this : this;\n        return params.push.apply(params, arguments) <\n            f.length && arguments.length ?\n          _curry.call(context, params) : f.apply(context, params);\n      } : f;\n    };\n    return _curry();\n  }\n  function compose$(fs){\n    return function(){\n      var i, args = arguments;\n      for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }\n      return args[0];\n    };\n  }\n}).call(this);\n\n//@ sourceURL=/src/media/scripts/scope.js"
));
require("/src/media/scripts/scope.js");
})();
